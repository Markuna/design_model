# 设计模式

### 三大类

总体来讲，设计模式分为三大类：
创建型模式（五种）：

- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

结构性模式（七种）：

- 适配器模式
- 装饰器模式
- 代理模式
- 外观模式
- 桥街模式
- 组合模式
- 享元模式

行为模式（十一种）：

- 策略模式
- 模板方法模式
- 观察者模式
- 迭代子模式
- 责任链模式
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式

额外的两类：

- 并发行模式
- 线程池模式

![image][![005LWjb2gy1fvttfn94jqj30l50pejto.jpg](http://wx2.sinaimg.cn/mw690/005LWjb2gy1fvttfn94jqj30l50pejto.jpg)]

## 设计模式的六大原则

总原则：开闭原则（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

1. 单一职责原则

  不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。


2. 里氏替换原则（Liskov Substitution Principle）

  里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

 

3. 依赖倒转原则（Dependence Inversion Principle）

  这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

 

4. 接口隔离原则（Interface Segregation Principle）
  
  这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

 

5. 迪米特法则（最少知道原则）（Demeter Principle）

就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

 

6. 合成复用原则（Composite Reuse Principle）

原则是尽量首先使用合成/聚合的方式，而不是使用继承。

### 简单工厂模式

简单工厂模式分为三种：普通简单工厂模式、多方法简单工厂模式、静态方法简单工厂

- **普通简单工厂模式**：就是创建一个工厂类，对于实现同一接口或父类的方法进行实例创建。工厂方法按照入参返回具体的不同实例，结合多态使用。
- **多方法简单工厂模式**：在普通简单工厂模式的基础上，工厂类改入参控制的方式，以调用的方式来返回具体实例。
- **静态方法简单工厂模式**：将工厂类静态化，不需要创建具体工厂类实例，直接以类名方式调用实际方法来获取实例。

```java
  public static void main(String[] args){
    //普通简单工厂模式
    Factory factory = new Factory("可口可乐");
    CocaCola cocaCola = factory.create();
    //多方法简单工厂模式
    MultFactory multFactory = new MultFactory();
    cocaCola = multFactory.createCoca();
    PepsiCola pepsiCola = multFactory.createPepsi();
    //静态方法简单工厂模式
    IceCream iceCream = StaticFactory.createIceCream();

  }
```

上述三种方法，都是将工厂类作为一个实际出口，来获取需要的东西。横向的去扩展父类或接口的实现类，加上修改工厂类就可以实现更多功能的扩展。三种不同的方法都是在工厂类上做变化，实际使用并无太大区别。
但在使用上并没有达到开闭原则，扩展时仍需要对工厂类做代码修改，并不是完善的工厂模式，故称为简单工厂模式。

### 工厂模式

工厂模式分为工厂方法模式和抽象工厂模式：

工厂模式就是在简单工厂模式的基础之上，将工厂类也进行抽象；即，抽象出一个工厂类，然后实现具体的工厂实现类，这样在扩展功能的时候，就可以像扩展产品类一样，去扩展工厂类，实现开闭原则；将具体的代码变更，放到客户端上。

示例：
```java
public static void main(String[] args){
    Factory factory = new CocaColaFactory();
    CocaCola CocaCola = factory.create();
    
    factory = new IceCreamFactory();
    IceCream iceCream = factory.create();
}
```

### 单例模式

单例模式保证在一个jvm中只会有一个实例对象出现，
